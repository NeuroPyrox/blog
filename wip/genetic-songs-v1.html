<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Genetic Songs</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Nova+Mono&display=swap");

    body {
      background-color: black;
      font-family: "Nova Mono", monospace;
      color: #0F0;
      line-height: 2.5;
    }

    a:link,
    a:visited {
      color: #FF0;
    }
  </style>
  <body>
    Usually the button doesn't play any sound. This isn't a glitch, it's just
    cause the genetic algorithm sucks.
    <br />
    <button id="next">
      Next
    </button>
    <br />
    The fitness of each song is measured by how long you let it play. "Next"
    skips to the next song.
  </body>
  <script>
    const newWeightedLeaf = (value, weight) => {
      const result = {
        weight,
        size: 1,
        removeChildIndex: (index, sibling) => sibling,
        popChildWeight: (weight, sibling) => [sibling, [value, weight]]
      };
      result.pushWeightedLeaf = leaf => newWeightedBranch(result, leaf);
      return result;
    };

    const newWeightedBranch = (left, right) => {
      const popWeight = weight =>
        weight < left.weight
          ? left.popChildWeight(weight, right)
          : right.popChildWeight(weight - left.weight, left);
      const popChildWeight = (weight, sibling) => {
        const [newChild, value] = popWeight(weight);
        return [newWeightedBranch(newChild, sibling), value];
      };
      const removeIndex = index =>
        index < left.size
          ? left.removeChildIndex(index, right)
          : right.removeChildIndex(index - left.size, left);
      const removeChildIndex = (index, sibling) =>
        newWeightedBranch(removeIndex(index), sibling);
      return {
        weight: left.weight + right.weight,
        size: left.size + right.size,
        pushWeightedLeaf: leaf =>
          left.size < right.size
            ? newWeightedBranch(left.pushWeightedLeaf(leaf), right)
            : newWeightedBranch(left, right.pushWeightedLeaf(leaf)),
        popWeight,
        popChildWeight,
        removeIndex,
        removeChildIndex
      };
    };
    
    const test = x => {
      if (x.apply === undefined) {
        console.log(x)
      }
      return x;
    }

    const getLeafMutations = f =>
      [x => test(x).apply(f), x => f.apply(x)]
        .map(mutation => initialLambdas.map(mutation))
        .flat();

    const getBranchMutations = (fx, f, x) =>
      getLeafMutations(fx)
        .concat(f.isLeaf ? [x] : [])
        .concat(x.isLeaf ? [f] : [])
        .concat(f.getMutations().map(mf => mf.apply(x)))
        .concat(x.getMutations().map(mx => f.apply(mx)));

    const newLambda = fInner => {
      const f = {};
      f.isLeaf = true;
      f.getMutations = () => getLeafMutations(f);
      f.eval = gas => [f, gas];
      f.apply = x => {
        const fx = {};
        fx.getMutations = () => getBranchMutations(fx, f, x);
        fx.eval = gas => {
          if (gas <= 0) {
            return [null, -1];
          }
          const [evalX, gasX] = x.eval(gas - 1);
          if (gasX < 0) {
            return [null, -1];
          }
          return fInner(evalX).eval(gasX);
        };
        fx.apply = y => newLambdaApplication(fx, y);
        return fx;
      };
      return f;
    };

    const newLambdaApplication = (f, x) => {
      const fx = {};
      fx.getMutations = () => getBranchMutations(fx, f, x);
      fx.eval = gas => {
        if (gas <= 0) {
          return [null, -1];
        }
        const [evalF, gasF] = f.eval(gas - 1);
        const [evalX, gasX] = x.eval(gasF);
        if (gasX < 0) {
          return [null, -1];
        }
        return evalF.apply(evalX).eval(gasX);
      };
      fx.apply = y => newLambdaApplication(fx, y);
      return fx;
    };

    const newLambdaNumber = xNumber => {
      const x = newLambda(operator =>
        newLambda(y => {
          const xy = {};
          xy.eval = gas =>
            gas <= 0 ||
            operator.applyOperator === undefined ||
            y.number === undefined
              ? [null, -1]
              : [
                  newLambdaNumber(operator.applyOperator(xNumber, y.number)),
                  gas - 1
                ];
          xy.apply = z => newLambdaApplication(xy, z);
          return xy;
        })
      );
      x.number = xNumber;
      return x;
    };

    const combinators = [
      newLambda(x =>
        newLambda(y => newLambda(z => x.apply(z).apply(y.apply(z))))
      ),
      newLambda(x => newLambda(y => x)),
      newLambda(x => x),
      newLambda(x => newLambda(y => y.apply(x))),
      newLambda(x => newLambda(y => newLambda(z => x.apply(y.apply(z))))),
      newLambda(x => newLambda(y => newLambda(z => x.apply(z).apply(y)))),
      newLambda(x => newLambda(y => newLambda(z => x.apply(y)))),
      newLambda(z => z.apply(z)),
      newLambda(y => newLambda(z => z.apply(y.apply(z)))),
      newLambda(x => newLambda(z => x.apply(z).apply(z)))
    ];

    const operators = [
      (x, y) => x + y,
      (x, y) => x - y,
      (x, y) => x * y,
      (x, y) => x / y,
      (x, y) => x % y,
      (x, y) => x & y,
      (x, y) => x | y,
      (x, y) => x ^ y,
      (x, y) => x << y,
      (x, y) => x >> y,
      (x, y) => x >>> y
    ].map(applyOperator => {
      const result = {applyOperator};
      result.eval = gas => [result, gas];
      result.apply = _ => {
        const err = {};
        err.eval = _ => [null, -1];
        err.apply = _ => err;
        return err;
      }
    });

    const initialLambdas = [newLambdaNumber(1)]
      .concat(combinators)
      .concat(operators);

    const initialSongWeight = 100;
    let songs = newWeightedLeaf(initialLambdas[0], initialSongWeight);
    initialLambdas.slice(1).forEach(lambda => {
      songs = songs.pushWeightedLeaf(
        newWeightedLeaf(lambda, initialSongWeight)
      );
    });
    const maxNumSongs = 10000;
    const songGas = 1000;
    const sampleGas = 20;

    const removeExcessSongs = () => {
      while (maxNumSongs < songs.size) {
        songs = songs.removeIndex(Math.random() * songs.size);
      }
    };

    const pushSongMutations = (song, weight) => {
      const mutations = song.getMutations();
      weight /= mutations.length;
      mutations.foreach(mutation => {
        songs = songs.pushWeightedLeaf(newWeightedLeaf(mutation, weight));
      });
      removeExcessSongs();
    };

    const popUnrenderedSong = () => {
      const [newSongs, result] = songs.popWeight(Math.random() * songs.weight);
      songs = newSongs;
      return result;
    };

    // The code from here onward is messy because I'm not reusing functions enough to know the correct abstractions

    const popNextValidSong = () => {
      for (;;) {
        const [song, weight] = popUnrenderedSong();
        if (song.applyOperator === undefined) {
          const [evalSong] = song.eval(songGas);
          if (evalSong !== null && evalSong.applyOperator === undefined) {
            const [evalSample] = evalSong
              .apply(newLambdaNumber(0))
              .eval(sampleGas);
            if (evalSample !== null && evalSample.number !== undefined) {
              return [song, evalSong, weight];
            }
          }
        }
        pushSongMutations(song, weight);
      }
    };

    const renderSong = evalSong => {
      const buffer = audioCtx.createBuffer(
        1,
        audioCtx.sampleRate * 60,
        audioCtx.sampleRate
      );
      const channel = buffer.getChannelData(0);
      for (let t = 0; t < buffer.length; ++t) {
        const [value] = evalSong.apply(newLambdaNumber(t)).eval(sampleGas);
        channel[t] = value.number;
      }
      bufferSource = audioCtx.createBufferSource();
      bufferSource.buffer = buffer;
      return bufferSource;
    };

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let currentSource = null;
    let currentSong = null;
    let currentWeight = null;
    let lastStartTime = 0;

    const playNextSong = () => {
      const endTime = audioCtx.currentTime;
      const [song, evalSong, weight] = popNextValidSong();
      source = renderSong(evalSong);
      source.onended = playNextSong;
      source.connect(audioCtx.destination);
      if (currentSong !== null) {
        pushSongMutations(currentSong, currentWeight + endTime - lastStartTime);
      }
      currentSource = source;
      currentSong = song;
      currentWeight = weight;
      lastStartTime = audioCtx.currentTime;
      source.start();
      document.getElementById("next").innerHTML = "Next";
    };

    document.getElementById("next").onclick = () => {
      document.getElementById("next").innerHTML = "...";
      if (currentSource === null) {
        playNextSong();
      } else {
        currentSource.stop();
      }
    };
  </script>
</html>
