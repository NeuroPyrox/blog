<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Genetic Songs</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Nova+Mono&display=swap");

    body {
      background-color: black;
      font-family: "Nova Mono", monospace;
      color: #0F0;
      line-height: 2.5;
    }

    a:link,
    a:visited {
      color: #FF0;
    }
  </style>
  <body>
    <button id="next">
      Next
    </button>
    <p>
      WIP
    </p>
  </body>
  <script>
    const assert = (condition, message = "Assertion Error!") => {
      if (!condition) {
        throw message;
      }
    };

    const createBranch = args => ({
      match: ({ branch }) => branch(args)
    });

    const createLeaf = args => ({
      match: ({ leaf }) => leaf(args)
    });

    const getTreeSize = tree =>
      tree.match({
        branch: ({ size }) => size,
        leaf: _ => 1
      });

    const getTreeEnergy = tree =>
      tree.match({
        branch: ({ energy }) => energy,
        leaf: ({ energy }) => energy
      });

    const push = (tree, value, energy) =>
      tree.match({
        branch: ({ size, energy: branchEnergy, left, right }) => {
          if (getTreeSize(left) < getTreeSize(right)) {
            return createBranch({
              size: size + 1,
              energy: branchEnergy + energy,
              left: push(left, value, energy),
              right
            });
          } else {
            return createBranch({
              size: size + 1,
              energy: branchEnergy + energy,
              left,
              right: push(right, value, energy)
            });
          }
        },
        leaf: ({ energy: leafEnergy, value: leafValue }) =>
          createBranch({
            size: 2,
            energy: leafEnergy + energy,
            left: createLeaf({ energy: leafEnergy, value: leafValue }),
            right: createLeaf({ energy, value })
          })
      });

    // Has the same structure as popByEnergy, but it's not worth refactoring yet
    const popByIndex = (tree, index) =>
      tree.match({
        branch: ({ size, energy, left, right }) => {
          const leftSize = getTreeSize(left);
          const branch = index < leftSize;
          const child = branch ? left : right;
          const other = branch ? right : left;
          child.match({
            branch: _ => {
              if (!branch) {
                index -= leftSize;
              }
              const { tree: childResult, popped } = popByIndex(child, index);
              return {
                tree: createBranch({
                  size: size - 1,
                  energy: energy - popped.energy,
                  left: childResult,
                  right: other
                }),
                popped
              };
            },
            leaf: popped => ({ tree: other, popped })
          });
        }
      });

    const popByEnergy = (tree, energy) =>
      tree.match({
        branch: ({ size, branchEnergy, left, right }) => {
          const leftEnergy = getTreeEnergy(left);
          const branch = energy < leftEnergy;
          const child = branch ? left : right;
          const other = branch ? right : left;
          child.match({
            branch: _ => {
              if (!branch) {
                energy -= leftEnergy;
              }
              const { tree: childResult, popped } = popByEnergy(child, energy);
              return {
                tree: createBranch({
                  size: size - 1,
                  energy: branchEnergy - popped.energy,
                  left: childResult,
                  right: other
                }),
                popped
              };
            },
            leaf: popped => ({ tree: other, popped })
          });
        }
      });

    //     const pickNextSong = () => {
    //       const energy = Math.random() * getTreeEnergy(songs);
    //       return popByEnergy(songs, energy);
    //     };

    //     const removeOneSong = () => {
    //       const index = Math.floor(Math.random() * getTreeSize(songs));
    //       popByIndex(songs, index);
    //     };

    const combinatorS = {
      apply: x => ({
        apply: y => ({
          apply: z => x.apply(z).apply(y.apply(z))
        })
      })
    };

    const combinatorK = {
      apply: x => ({
        apply: y => x
      })
    };

    const combinatorI = {
      apply: x => x
    };

    const combinatorB = {
      apply: x => ({
        apply: y => ({
          apply: z => x.apply(y.apply(z))
        })
      })
    };

    const combinatorC = {
      apply: x => ({
        apply: y => ({
          apply: z => x.apply(z).apply(y)
        })
      })
    };

    const newNumber = x => ({
      apply: op => ({
        apply: y => op.applyOperator(x, y)
      })
    });

    const operatorAdd = {
      applyOperator: (x, y) => x + y
    };

    const operatorSubtract = {
      applyOperator: (x, y) => x - y
    };

    const operatorMultiply = {
      applyOperator: (x, y) => x * y
    };

    const operatorDivide = {
      applyOperator: (x, y) => x / y
    };

    const operatorModulus = {
      applyOperator: (x, y) => x % y
    };

    const operatorAnd = {
      applyOperator: (x, y) => x & y
    };

    const operatorOr = {
      applyOperator: (x, y) => x | y
    };

    const operatorXor = {
      applyOperator: (x, y) => x ^ y
    };

    const operatorLeftShift = {
      applyOperator: (x, y) => x << y
    };

    const operatorSignedRightShift = {
      applyOperator: (x, y) => x >> y
    };

    const operatorUnsignedRightShift = {
      applyOperator: (x, y) => x >>> y
    };

    const newExpression = (a, b) => ({
      eval: () => {
        const evalA = (a.eval ?? (() => a))();
        const evalB = (b.eval ?? (() => b))();
        return evalA.apply(evalB);
      }
    });

    //         const renderSong = song => {
    //           [song] = reduceFully(song, 1000);
    //           if (song === null) {
    //             return null;
    //           }
    //           const [test] = reducePartially(song, 0, 100);
    //           if (test === null) {
    //             return null;
    //           }
    //           const myArrayBuffer = audioCtx.createBuffer(
    //             1,
    //             audioCtx.sampleRate * 30,
    //             audioCtx.sampleRate
    //           );
    //           const nowBuffering = myArrayBuffer.getChannelData(0);
    //           for (let t = 0; t < myArrayBuffer.length; ++t) {
    //             const [value] = reducePartially(song, t, 100);
    //             nowBuffering[t] = value;
    //           }
    //           song = audioCtx.createBufferSource();
    //           song.buffer = myArrayBuffer;
    //           return song;
    //         };

    //         const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    //         let currentSong = null;
    //         let lastStartTime = 0;

    //         const startNextSong = () => {
    //           source = generateSong();
    //           source.onended = startNextSong;
    //           source.connect(audioCtx.destination);
    //           source.start();
    //           const nextStartTime = audioCtx.currentTime;
    //           console.log(nextStartTime - lastStartTime);
    //           lastStartTime = nextStartTime;
    //         };

    //         document.getElementById("next").onclick = () => {
    //           if (currentSong === null) {
    //             currentSong = popRandomSongByEnergy();
    //             const source = renderSong(currentSong);
    //             if (source === null) {
    //               // todo
    //             }

    //             startNextSong();
    //           } else {
    //             source.stop();
    //           }
    //         };
  </script>
</html>
