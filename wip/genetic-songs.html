<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Genetic Songs</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Nova+Mono&display=swap");

    body {
      background-color: black;
      font-family: "Nova Mono", monospace;
      color: #0F0;
      line-height: 2.5;
    }

    a:link,
    a:visited {
      color: #FF0;
    }
  </style>
  <body>
    <button id="next">
      Next
    </button>
    <p>
      WIP
    </p>
  </body>
  <script>
    const assert = (condition, message = "Assertion Error!") => {
      if (!condition) {
        throw message;
      }
    };
    
    const createBranch = args => ({
      match: ({ branch }) => branch(args)
    });

    const createLeaf = args => ({
      match: ({ leaf }) => leaf(args)
    });

    const getTreeSize = tree =>
      tree.match({
        branch: ({ size }) => size,
        leaf: _ => 1
      });

    const getTreeEnergy = tree =>
      tree.match({
        branch: ({ energy }) => energy,
        leaf: ({ energy }) => energy
      });

    const push = (tree, value, energy) =>
      tree.match({
        branch: ({ size, energy: branchEnergy, left, right }) => {
          if (getTreeSize(left) < getTreeSize(right)) {
            return createBranch({
              size: size + 1,
              energy: branchEnergy + energy,
              left: push(left, value, energy),
              right
            });
          } else {
            return createBranch({
              size: size + 1,
              energy: branchEnergy + energy,
              left,
              right: push(right, value, energy)
            });
          }
        },
        leaf: ({ energy: leafEnergy, value: leafValue }) =>
          createBranch({
            size: 2,
            energy: leafEnergy + energy,
            left: createLeaf({ energy: leafEnergy, value: leafValue }),
            right: createLeaf({ energy, value })
          })
      });

    // Has the same structure as popByEnergy, but it's not worth refactoring yet
    const popByIndex = (tree, index) =>
      tree.match({
        branch: ({ size, energy, left, right }) => {
          const leftSize = getTreeSize(left);
          const branch = index < leftSize;
          const child = branch ? left : right;
          const other = branch ? right : left;
          child.match({
            branch: _ => {
              if (!branch) {
                index -= leftSize;
              }
              const { tree: childResult, popped } = popByIndex(child, index);
              return {
                tree: createBranch({
                  size: size - 1,
                  energy: energy - popped.energy,
                  left: childResult,
                  right: other
                }),
                popped
              };
            },
            leaf: popped => ({ tree: other, popped })
          });
        }
      });

    const popByEnergy = (tree, energy) =>
      tree.match({
        branch: ({ size, branchEnergy, left, right }) => {
          const leftEnergy = getTreeEnergy(left);
          const branch = energy < leftEnergy;
          const child = branch ? left : right;
          const other = branch ? right : left;
          child.match({
            branch: _ => {
              if (!branch) {
                energy -= leftEnergy;
              }
              const { tree: childResult, popped } = popByEnergy(child, energy);
              return {
                tree: createBranch({
                  size: size - 1,
                  energy: branchEnergy - popped.energy,
                  left: childResult,
                  right: other
                }),
                popped
              };
            },
            leaf: popped => ({ tree: other, popped })
          });
        }
      });
    
    let songs = createLeaf({energy: 1000, value: "S"});

    for (const song of [
      "K",
      "I",
      "B",
      "C",
      "+",
      "-",
      "*",
      "/",
      "%",
      "&",
      "|",
      "~",
      "^",
      "<<",
      ">>",
      ">>>",
      1
    ]) {
      push(songs, song, 1000);
    }

    const pickNextSong = () => {
      const energy = Math.random() * getTreeEnergy(songs);
      return popByEnergy(songs, energy);
    };

    const removeOneSong = () => {
      const index = Math.floor(Math.random() * getTreeSize(songs));
      popByIndex(songs, index);
    };

    const evalS = (x, y, z, gas) => {
      let xz, yz;
      [xz, gas] = reducePartially(x, z, gas);
      [yz, gas] = reducePartially(y, z, gas);
      return reducePartially(xz, yz, gas);
    };

    const evalB = (x, y, z, gas) => {
      let yz;
      [yz, gas] = reducePartially(y, z, gas);
      return reducePartially(x, yz, gas);
    };

    const evalC = (x, y, z, gas) => {
      const xz = reducePartially(x, z, gas);
      return reducePartially(xz, y, gas);
    };

    // Assume inputs are evaluated and non-null
    const evalLambda1 = (f, x, gas) => {
      if (f === "I") {
        return [x, gas];
      }
      if (f === "~") {
        if (typeof x === "number") {
          return [~x, gas];
        }
        return [null, 0];
      }
      return [[f, x], gas];
    };

    // Assume inputs are evaluated and non-null
    const evalLambda2 = (f, x, y, gas) => {
      if (f === "K") {
        return [x, gas];
      }
      if (typeof x !== "number" || typeof y !== "number") {
        return [null, 0];
      }
      switch (f) {
        case "+":
          return [x + y, gas];
        case "-":
          return [x - y, gas];
        case "*":
          return [x * y, gas];
        case "/":
          return [x / y, gas];
        case "%":
          return [x % y, gas];
        case "&":
          return [x & y, gas];
        case "|":
          return [x | y, gas];
        case "^":
          return [x ^ y, gas];
        case "<<":
          return [x << y, gas];
        case ">>":
          return [x >> y, gas];
        case ">>>":
          return [x >>> y, gas];
        default:
          return [[f, x, y], gas];
      }
    };

    // Assume inputs are evaluated and non-null
    const evalLambda3 = (f, x, y, z, gas) => {
      switch (f) {
        case "S":
          return evalS(x, y, z, gas);
        case "B":
          return evalB(x, y, z, gas);
        case "C":
          return evalC(x, y, z, gas);
        default:
          assert(false);
      }
    };

    // Assume inputs are evaluated and non-null
    const reducePartially = (a, b, gas) => {
      --gas;
      if (gas <= 0) {
        return [null, 0];
      }
      if (typeof a === "number") {
        return [null, 0];
      }
      if (typeof a === "string") {
        return evalLambda1(a, b, gas);
      }
      assert(Array.isArray(a));
      if (a.length === 2) {
        return evalLambda2(a[0], a[1], b, gas);
      }
      assert(a.length === 3);
      return evalLambda3(a[0], a[1], a[2], b, gas);
    };

    // Assume sexpr isn't evaluated
    const reduceFully = (sexpr, gas) => {
      if (typeof sexpr === "number") {
        return sexpr;
      }
      if (typeof sexpr === "string") {
        return sexpr;
      }
      assert(Array.isArray(sexpr));
      assert(sexpr.length === 2);
      let a, b;
      [a, gas] = reduceFully(sexpr[0], gas);
      [b, gas] = reduceFully(sexpr[1], gas);
      return reducePartially(a, b, gas);
    };

    const renderSong = song => {
      [song] = reduceFully(song, 1000);
      if (song === null) {
        return null;
      }
      const [test] = reducePartially(song, 0, 100);
      if (test === null) {
        return null;
      }
      const myArrayBuffer = audioCtx.createBuffer(
        1,
        audioCtx.sampleRate * 30,
        audioCtx.sampleRate
      );
      const nowBuffering = myArrayBuffer.getChannelData(0);
      for (let t = 0; t < myArrayBuffer.length; ++t) {
        const [value] = reducePartially(song, t, 100);
        nowBuffering[t] = value;
      }
      song = audioCtx.createBufferSource();
      song.buffer = myArrayBuffer;
      return song;
    };

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let currentSong = null;
    let lastStartTime = 0;

    const startNextSong = () => {
      source = generateSong();
      source.onended = startNextSong;
      source.connect(audioCtx.destination);
      source.start();
      const nextStartTime = audioCtx.currentTime;
      console.log(nextStartTime - lastStartTime);
      lastStartTime = nextStartTime;
    };

    document.getElementById("next").onclick = () => {
      if (currentSong === null) {
        currentSong = popRandomSongByEnergy();
        const source = renderSong(currentSong);
        if (source === null) {
          // todo
        }

        startNextSong();
      } else {
        source.stop();
      }
    };
  </script>
</html>
