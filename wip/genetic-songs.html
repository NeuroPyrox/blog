<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Genetic Songs</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Nova+Mono&display=swap");

    body {
      background-color: black;
      font-family: "Nova Mono", monospace;
      color: #0F0;
      line-height: 2.5;
    }

    a:link,
    a:visited {
      color: #FF0;
    }
  </style>
  <body>
    <button id="next">
      Next
    </button>
    <p>
      WIP
    </p>
  </body>
  <script>
    // I'd use classes instead of closures, but that would be too verbose
    const newWeightedLeaf = (value, weight) => ({
      weight,
      size: 1,
      pushWeightedLeaf: leaf =>
        newWeightedBranch(newWeightedLeaf(value, weight), leaf),
      popChildIndex: (index, sibling) => [sibling, value],
      removeChildWeight: (weight, sibling) => sibling
    });

    const newWeightedBranch = (left, right) => {
      const popIndex = index =>
        index < left.size
          ? left.popChildIndex(index, right)
          : right.popChildIndex(index - left.size, left);
      const popChildIndex = (index, sibling) => {
        const [newChild, value] = popIndex(index);
        return [newWeightedBranch(newChild, sibling), value];
      };
      const removeWeight = weight =>
        weight < left.weight
          ? left.removeChildWeight(weight, right)
          : right.removeChildWeight(weight - left.weight, left);
      const removeChildWeight = (weight, sibling) =>
        newWeightedBranch(removeWeight(weight), sibling);
      return {
        weight: left.weight + right.weight,
        size: left.size + right.size,
        pushWeightedLeaf: leaf =>
          left.size < right.size
            ? newWeightedBranch(left.pushWeightedLeaf(leaf), right)
            : newWeightedBranch(left, right.pushWeightedLeaf(leaf)),
        popIndex,
        popChildIndex,
        removeWeight,
        removeChildWeight
      };
    };

    //     const pickNextSong = () => {
    //       const energy = Math.random() * getTreeEnergy(songs);
    //       return popByEnergy(songs, energy);
    //     };

    //     const removeOneSong = () => {
    //       const index = Math.floor(Math.random() * getTreeSize(songs));
    //       popByIndex(songs, index);
    //     };

    const combinatorS = {
      apply: x => ({
        apply: y => ({
          apply: z => x.apply(z).apply(y.apply(z))
        })
      })
    };

    const combinatorK = {
      apply: x => ({
        apply: y => x
      })
    };

    const combinatorI = {
      apply: x => x
    };

    const combinatorB = {
      apply: x => ({
        apply: y => ({
          apply: z => x.apply(y.apply(z))
        })
      })
    };

    const combinatorC = {
      apply: x => ({
        apply: y => ({
          apply: z => x.apply(z).apply(y)
        })
      })
    };

    const newNumber = x => ({
      apply: op => ({
        apply: y => op.applyOperator(x, y)
      })
    });

    const operatorAdd = {
      applyOperator: (x, y) => x + y
    };

    const operatorSubtract = {
      applyOperator: (x, y) => x - y
    };

    const operatorMultiply = {
      applyOperator: (x, y) => x * y
    };

    const operatorDivide = {
      applyOperator: (x, y) => x / y
    };

    const operatorModulus = {
      applyOperator: (x, y) => x % y
    };

    const operatorAnd = {
      applyOperator: (x, y) => x & y
    };

    const operatorOr = {
      applyOperator: (x, y) => x | y
    };

    const operatorXor = {
      applyOperator: (x, y) => x ^ y
    };

    const operatorLeftShift = {
      applyOperator: (x, y) => x << y
    };

    const operatorSignedRightShift = {
      applyOperator: (x, y) => x >> y
    };

    const operatorUnsignedRightShift = {
      applyOperator: (x, y) => x >>> y
    };

    const newExpression = (a, b) => ({
      eval: () => {
        const evalA = (a.eval ?? (() => a))();
        const evalB = (b.eval ?? (() => b))();
        return evalA.apply(evalB);
      }
    });

    //         const renderSong = song => {
    //           [song] = reduceFully(song, 1000);
    //           if (song === null) {
    //             return null;
    //           }
    //           const [test] = reducePartially(song, 0, 100);
    //           if (test === null) {
    //             return null;
    //           }
    //           const myArrayBuffer = audioCtx.createBuffer(
    //             1,
    //             audioCtx.sampleRate * 30,
    //             audioCtx.sampleRate
    //           );
    //           const nowBuffering = myArrayBuffer.getChannelData(0);
    //           for (let t = 0; t < myArrayBuffer.length; ++t) {
    //             const [value] = reducePartially(song, t, 100);
    //             nowBuffering[t] = value;
    //           }
    //           song = audioCtx.createBufferSource();
    //           song.buffer = myArrayBuffer;
    //           return song;
    //         };

    //         const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    //         let currentSong = null;
    //         let lastStartTime = 0;

    //         const startNextSong = () => {
    //           source = generateSong();
    //           source.onended = startNextSong;
    //           source.connect(audioCtx.destination);
    //           source.start();
    //           const nextStartTime = audioCtx.currentTime;
    //           console.log(nextStartTime - lastStartTime);
    //           lastStartTime = nextStartTime;
    //         };

    //         document.getElementById("next").onclick = () => {
    //           if (currentSong === null) {
    //             currentSong = popRandomSongByEnergy();
    //             const source = renderSong(currentSong);
    //             if (source === null) {
    //               // todo
    //             }

    //             startNextSong();
    //           } else {
    //             source.stop();
    //           }
    //         };
  </script>
</html>
